'''
Файл содержит конструкции для Лабораторной работы 4:
'''

# п. 1: Минимум 2 разные функции, которые принимают на вход один или несколько параметров.
# Функции ДОЛЖНЫ выбрасывать исключение при определённых значениях входных параметров.
# Функции НЕ ДОЛЖНЫ содержать никаких обработчиков исключений.
def divide(a, b):
    '''Функция делит первую переменную на вторую. Если вторая равна нулю, выбрасывает исключение'''
    if b == 0:
        raise ZeroDivisionError("Происходит деление на ноль")
    return a / b

def check_number_negativity(number):
    '''Функция проверяет значение переменной. Если она отрицательна, выбрасывает исключение'''
    if number < 0:
        raise ValueError("Число должно быть положительным")
    return True

# п. 2: Функция, которая принимает на вход один или несколько параметров.
# Функция ДОЛЖНА выбрасывать исключение при определённых значениях входных параметров.
# Функция ДОЛЖНА содержать ОДИН обработчик исключений общего типа (Exception).
# Внутри блока обработки исключения ДОЛЖНА быть какая-то логика связанная с обработкой исключения.
# Обработчик НЕ ДОЛЖЕН содержать блок finally.
def safe_divide(a, b):
    '''Функция производит деление двух переменных и обрабатывает исключение ZeroDivisionError'''
    try:
        result = divide(a, b)
        return result
    except ZeroDivisionError as e:
        print(f"Ошибка: {e}")
        return None

# п. 3: Функция, которая принимает на вход один или несколько параметров.
# Функция ДОЛЖНА выбрасывать исключение при определённых значениях входных параметров.
# Функция ДОЛЖНА содержать ОДИН обработчик исключений общего типа (Exception).
# Внутри блока обработки исключения ДОЛЖНА быть какая-то логика связанная с обработкой исключения.
# Обработчик ДОЛЖЕН содержать блок finally.
# Логика внутри блока finally ДОЛЖНА способствовать нормальному завершению работы функции.
def safe_check_number_negativity(number):
    '''Функция проверяет, положительно ли число и обрабатывает исключение, если нет'''
    try:
        check_number_negativity(number)
        return "Число положительное"
    except ValueError as e:
        print(f"Ошибка: {e}")
        return None
    finally:
        print("Проверка завершена")

# п. 4: Минимум 3 разные функции, которые принимают на вход один или несколько параметров.
# Функции ДОЛЖНЫ выбрасывать исключения при определённых значениях входных параметров.
# Функции ДОЛЖНЫ содержать НЕСКОЛЬКО обработчиков РАЗНЫХ типов исключений (минимум 3 типа).
# Внутри блоков обработки исключения ДОЛЖНА быть какая-нибудь логика,
# связанная с обработкой соответствующего типа исключения.
# Каждый обработчик МОЖЕТ содержать блок finally.
# Логика внутри блока finally ДОЛЖНА способствовать нормальному завершению работы функции.
def divide_numbers(a, b):
    '''Функция делит числа и обрабатывает исключения'''
    try:
        if b == 0:
            raise ZeroDivisionError("Деление на ноль")
        if a < 0:
            raise ValueError("Первый параметр отрицателен")
        if b < 0:
            raise ValueError("Второй параметр отрицателен")
        return a / b
    except ZeroDivisionError as e:
        print(f"Ошибка деления: {e}")
    except ValueError as e:
        print(f"Ошибка: {e}")
    finally:
        print("Завершение обработки")

def key_word_guess(word):
    '''Функция делит числа и обрабатывает исключения'''
    try:
        if not isinstance(word, str):
            raise TypeError("Слово должно быть в виде строки")
        if word != "zachet":
            raise ValueError("Неверное значение")
        return True
    except TypeError as e:
        print(f"Обработана ошибка типа: {e}")
    except ValueError as e:
        print(f"Обработана ошибка значения: {e}")
    finally:
        print("Завершение обработки значения.")

def access_dict(dictionary, key):
    '''Функция работает со словарем и обрабатывает исключения'''
    try:
        if not isinstance(key,str):
            raise TypeError("Ключ должен быть в виде строки")
        if len(dictionary) <= 0:
            raise LookupError("Словарь ничего не содержит")
        return dictionary[key]
    except KeyError:
        print("Ошибка ключа: элемента с таким ключом не существует")
    except TypeError as e:
        print(f"Ошибка типа: {e}")
    except LookupError as e:
        print(f"Общая ошибка: {e}")
    finally:
        print("Завершение операции доступа к словарю.")

# п.5: Функция, которая принимает на вход один или несколько параметров.
# Функция ДОЛЖНА генерировать исключения при определённых условиях.
# Функция ДОЛЖНА содержать обрабоnчики всех исключений, которые генерируются внутри этой функции.
# Внутри блоков обработки исключения ДОЛЖНА быть какая-нибудь логика,
# связанная с обработкой соответствующего типа исключения.
# Обработчик МОЖЕТ содержать блок finally.
# Логика внутри блока finally ДОЛЖНА способствовать нормальному завершению работы функции.
def square_root(value):
    '''Функция вычисляет корень и обрабатывает исключения'''
    try:
        if value < 0:
            raise ValueError("Нельзя вычислить кв. корень из отрицательного числа.")
        result = value ** 0.5
        return result
    except ValueError as e:
        print(f"Ошибка: {e}")
    finally:
        print("Завершение операции вычисления корня")

# п.6: Минимум 3 разных пользовательских исключения и примеры их использования
class NegativeNumberError(Exception):
    '''Пример вызова: деление числа'''
    def __str__(self):
        return "Значение не может быть отрицательным"

class LargeNumberError(Exception):
    '''Пример вызова: число выходит за диапазон'''
    def __init__(self, number):
        self.number = number
    def __str__(self):
        return f"Значение выходит за предел {self.number}"

class InvalidNameError(Exception):
    '''Пример вызова: имя содержит ругательство'''
    def __str__(self):
        return "Значение недопустимо"

# п.7: Функция, которая принимает на вход один или несколько параметров.
# Функция ДОЛЖНА выбрасывать пользовательское исключение, созданное на шаге 6.
# Функция ДОЛЖНА содержать МИНИМУМ ОДИН обработчик исключений.
# Внутри блока обработки исключения ДОЛЖНА быть какая-то логика, связанная с обработкой исключения
# Обработчик МОЖЕТ содержать блок finally.
def name_input(name):
    '''Функция проверяет введенную строку и обрабатывает исключения'''
    try:
        if name == "Admin" or name == "root":
            raise InvalidNameError
        print(f"Введенное имя: {name} разрешено")
    except InvalidNameError as e:
        print(f"Ошибка: {e}")
    finally:
        print("Завершение операции проверки имени")

# п.8: Минимум 3 функции, демонстрирующие работу исключений.
def calculate_area(radius):
    '''Функция вычисляет площадь круга'''
    if radius < 0:
        raise ValueError("Радиус должен быть положительным")
    return 3.14 * radius ** 2

def glue_strings(s1, s2):
    '''Функция соединяет две строки'''
    if not isinstance(s1, str) or not isinstance(s2, str):
        raise TypeError("Оба аргумента должны быть строками.")
    return s1 + s2

def buy_goods(balance, amount):
    '''Функция вычитает из баланса цену за покупки'''
    if amount > balance:
        raise ValueError("На балансе недостаточно средств")
    return balance - amount
